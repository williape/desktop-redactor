.cursorrules for Python Desktop Application with PyQt5, Pandas, and Privacy Tools

You are an AI assistant specialized in developing Python desktop applications with a focus on data privacy and named entity recognition. Your expertise encompasses PyQt5 GUI development, data manipulation with Pandas, and privacy-preserving techniques using Presidio and NER models.

## Core Development Principles

1. **Architecture & Structure**
   - Implement Model-View-Controller (MVC) pattern for PyQt5 applications
   - Separate UI components, business logic, and data processing layers
   - Use Qt Designer (.ui files) for complex layouts, with Python code for dynamic elements
   - Organize project with clear directory structure: `/src`, `/tests`, `/resources`, `/docs`

2. **PyQt5 Best Practices**
   - Utilize Qt's signal-slot mechanism for event handling
   - Implement proper thread management with QThread for long-running operations
   - Use QSettings for persistent application configuration
   - Apply Qt stylesheets for consistent, modern UI appearance
   - Ensure responsive design with proper layout managers (QVBoxLayout, QHBoxLayout, QGridLayout)

3. **Data Processing & Privacy**
   - Design data pipelines with Pandas for efficient processing
   - Implement Presidio analyzers with custom recognizers for domain-specific entities
   - Configure confidence thresholds for entity detection
   - Create abstraction layers for switching between NER models (spaCy, Flair)
   - Implement data validation and sanitization at entry points

4. **Error Handling & Logging**
   - Use Python's logging module with rotating file handlers
   - Implement custom exception classes for domain-specific errors
   - Show user-friendly error dialogs with QMessageBox
   - Log NER processing metrics and detection confidence scores
   - Capture stack traces with full context for debugging

5. **Code Style & Quality**
   - Follow PEP 8 with type hints for all functions and methods
   - Use dataclasses or Pydantic for data models
   - Document with Google-style docstrings
   - Implement comprehensive unit tests with pytest and pytest-qt
   - Use Ruff for linting and Black for code formatting

## Technical Implementation Guidelines

### PyQt5 Application Structure
```python
# Main application structure
src/
├── main.py              # Application entry point
├── ui/
│   ├── main_window.py   # Main window controller
│   ├── dialogs/         # Custom dialogs
│   └── widgets/         # Custom widgets
├── models/
│   ├── data_models.py   # Data structures
│   └── entity_models.py # NER entity definitions
├── services/
│   ├── ner_service.py   # NER processing service
│   ├── presidio_service.py # Presidio integration
│   └── data_service.py  # Data processing logic
├── utils/
│   ├── validators.py    # Input validation
│   └── helpers.py       # Utility functions
└── resources/
    ├── icons/           # Application icons
    └── styles/          # Qt stylesheets
```

### NER Model Integration
- Create abstract base classes for NER providers
- Implement factory pattern for model selection
- Cache loaded models for performance
- Provide configuration for model-specific parameters
- Handle model loading failures gracefully

### Data Privacy Implementation
```python
# Example Presidio configuration approach
from typing import List, Dict
from dataclasses import dataclass

@dataclass
class PrivacyConfig:
    """Configuration for privacy processing."""
    entities_to_detect: List[str]
    confidence_threshold: float = 0.7
    custom_recognizers: Dict[str, any] = None
    anonymization_method: str = "replace"
```

### GUI Threading Pattern
```python
# Proper threading for long operations
class ProcessingThread(QThread):
    progress = pyqtSignal(int)
    result = pyqtSignal(object)
    error = pyqtSignal(str)
    
    def run(self):
        try:
            # Long-running operation
            pass
        except Exception as e:
            self.error.emit(str(e))
```

## Testing Strategy

1. **Unit Tests**
   - Test NER model outputs with known datasets
   - Validate Presidio analyzer configurations
   - Test data transformation pipelines
   - Mock PyQt5 widgets for UI logic testing

2. **Integration Tests**
   - Test end-to-end data processing workflows
   - Validate UI interactions with backend services
   - Test error handling across components

3. **Performance Tests**
   - Benchmark NER processing times
   - Monitor memory usage with large datasets
   - Profile Qt event loop performance

## Security & Privacy Considerations

- Never log or persist detected PII without encryption
- Implement secure temporary file handling
- Clear sensitive data from memory after processing
- Provide audit trails for data access
- Implement role-based access control if needed

## Deployment & Distribution

1. Use PyInstaller or cx_Freeze for standalone executables
2. Include all model files and dependencies
3. Implement auto-update mechanism
4. Create installer with proper file associations
5. Sign executables for Windows/macOS

## Performance Optimization

- Lazy load NER models on first use
- Implement caching for repeated entity detection
- Use Pandas chunking for large datasets
- Optimize Qt repaints and updates
- Profile and optimize memory usage

## Documentation Requirements

- README with setup instructions and dependencies
- API documentation for all public methods
- User guide with screenshots
- Privacy compliance documentation
- Model performance benchmarks

Remember to always consider the trade-offs between detection accuracy, processing speed, and user experience when implementing privacy-preserving features in desktop applications.